package models;

import java.awt.Image;

public class PPU {
	private Object IOPort;

	/**
	 * RAM【$0000-$1FFF】にマップされた512個のキャラクタデータはBGに256個、スプライトに256個を割り当てます。
	 * Gとスプライトのベースアドレス設定はI/Oポート【$2000】で設定する事が出来ます。
	 */
	private Image sprite;
	private Image backGround;

	private byte[] nameTable;
	private byte[] attributeTable;

	/**
	 * パターンテーブルはVRAM【$0000-$1FFF】にマッピング
	 */
	private byte[] patternTable;

	/**
	 * パレットテーブルはVRAM【$3F00-$3F1F】にマッピング
	 */
	private byte[] palletTable;

	/**
	 * 	// 1秒間に60回画面が更新される
	// 実際には240ラインを描画し
	// 20ライン程分の時間何も描画しない特殊な時間「VBlank」があり、通常VRAMにアクセスするのはこの期間内にする
	// VBlank中かどうかはI/O【$2002】のステータスビットで確認できる
	// VBlankが始まる時にNMI割り込みを発生させることも出来ます。
	 */
	private boolean isVBlank = false;
	// I/O【$2006】を使ってアクセスしたいVRAMのアドレスを登録します。
	// そしてI/O【$2007】に対して書き込みと読み込みを行うことでアクセスする事が出来ます。
	// VRAMに読み書きを行うとI/O【$2000】の2bit目の値によって、
	// 現在指しているVRAMのアドレスが1byteまたは32byteインクリメントされます。


	// ファミコンの画面構造は、4枚の横32ブロック縦30ブロックの仮想画面を上下左右に繋ぎ合わせたような構造

	// それぞれの画面には「ネームテーブル」(キャラクタ番号)と「属性テーブル」（着色レイアウト）があります。

	// 画面1のグラフィックテーブルはVRAM【$2000-$23FF】にマッピング
	// スクリーンバッファ#2と#3はINESヘッダによって、VRAM【$2400-$27FF】が画面2と画面3のどちらのグラフィックテーブルにマッピングされる

	// さらに「表示する範囲」を教えなければならないからです。この表示する範囲を設定するためにはスクロールレジスタI/O【$2005】にスクロールポジションを座標を書き込む

	//
}
